<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube Solver - AeroHack'25</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #f3f4f6;
            --bg-dark: #111827;
            --card-bg-light: rgba(255, 255, 255, 0.6);
            --card-bg-dark: rgba(31, 41, 55, 0.6);
            --text-light: #1f2937;
            --text-dark: #d1d5db;
            --text-strong-light: #000000;
            --text-strong-dark: #ffffff;
            --text-secondary-light: #4b5563;
            --text-secondary-dark: #9ca3af;
            --border-light: rgba(209, 213, 219, 0.8);
            --border-dark: #374151;
        }

        [data-theme="dark"] {
            --bg-color: var(--bg-dark);
            --card-bg-color: var(--card-bg-dark);
            --text-color: var(--text-dark);
            --text-strong-color: var(--text-strong-dark);
            --text-secondary-color: var(--text-secondary-dark);
            --border-color: var(--border-dark);
        }

        [data-theme="light"] {
            --bg-color: var(--bg-light);
            --card-bg-color: var(--card-bg-light);
            --text-color: var(--text-light);
            --text-strong-color: var(--text-strong-light);
            --text-secondary-color: var(--text-secondary-light);
            --border-color: var(--border-light);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease;
            overflow-y: scroll;
        }

        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite;
        }
        
        [data-theme="light"] .animated-bg {
             opacity: 0.15;
        }

        [data-theme="dark"] .animated-bg {
             opacity: 0.3;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .card {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #cube-container {
            width: 100%;
            height: 400px;
            cursor: grab;
            border-radius: 0.5rem;
        }
        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .step-item {
            transition: background-color 0.3s ease-in-out, border-color 0.3s ease-in-out;
            border-left-width: 4px;
            border-color: var(--border-color);
        }
        .step-item.active {
            background-color: rgba(59, 130, 246, 0.1);
            border-left-color: #3b82f6;
        }
        .step-item.completed {
            background-color: rgba(34, 197, 94, 0.1);
            border-left-color: #22c55e;
        }
        .step-item.completed .step-name {
            text-decoration: line-through;
            color: var(--text-secondary-color);
        }
        .btn-gradient-blue {
            background-image: linear-gradient(to right, #3b82f6, #60a5fa);
        }
        .btn-gradient-green {
            background-image: linear-gradient(to right, #22c55e, #4ade80);
        }
        .btn-gradient-gray {
            background-image: linear-gradient(to right, #6b7280, #9ca3af);
        }
        .info-label {
            color: var(--text-strong-color);
            font-weight: 600;
        }
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            margin: auto;
            display: block;
            width: 90%;
            max-width: 800px;
            animation-name: zoom;
            animation-duration: 0.3s;
        }
        @keyframes zoom {
            from {transform:scale(0)}
            to {transform:scale(1)}
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
            cursor: pointer;
        }
        .modal-close:hover, .modal-close:focus {
            color: #bbb;
            text-decoration: none;
        }
        #architecture-diagram {
            cursor: zoom-in;
        }
    </style>
</head>
<body class="text-gray-300">
    <div class="animated-bg"></div>
    <div id="main-container" class="container mx-auto p-4 md:p-8">
        <header class="relative text-center mb-8 p-6 card rounded-xl shadow-lg">
            <h1 class="text-4xl font-extrabold text-[--text-color]">Rubik's Cube Solver - AeroHack'25</h1>
            <p class="text-lg text-[--text-secondary-color] mt-2">Interactive Demo of Layer-by-Layer Algorithm</p>
            <div class="absolute top-4 right-4">
                <button id="theme-toggle" class="p-2 rounded-full bg-[--card-bg-color] border border-[--border-color] text-[--text-color] shadow-md">
                    <svg id="theme-icon-sun" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.106a.75.75 0 010 1.06l-1.591 1.59a.75.75 0 11-1.06-1.06l1.59-1.59a.75.75 0 011.06 0zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.894 17.894a.75.75 0 01-1.06 0l-1.59-1.591a.75.75 0 111.06-1.06l1.59 1.59a.75.75 0 010 1.06zM12 18a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM5.106 17.894a.75.75 0 010-1.06l1.59-1.591a.75.75 0 111.06 1.06l-1.59 1.59a.75.75 0 01-1.06 0zM4.5 12a.75.75 0 01-.75.75H1.5a.75.75 0 010-1.5h2.25a.75.75 0 01.75.75zM6.106 5.106a.75.75 0 011.06 0l1.591 1.59a.75.75 0 01-1.06 1.06l-1.59-1.591a.75.75 0 010-1.06z"></path></svg>
                    <svg id="theme-icon-moon" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                </button>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 space-y-8">
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold mb-4 text-center text-[--text-color]">Interactive 3D Cube</h2>
                    <div id="cube-container"></div>
                </div>
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold mb-4 text-[--text-color]">System Information</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <ul class="space-y-3 text-sm">
                                <li class="flex justify-between"><strong class="info-label">Cube Representation:</strong> <span class="text-[--text-secondary-color]">8 corners + 12 edges</span></li>
                                <li class="flex justify-between"><strong class="info-label">Move Engine:</strong> <span class="text-[--text-secondary-color]">18 total moves supported</span></li>
                                <li class="flex justify-between"><strong class="info-label">Algorithm:</strong> <span class="text-[--text-secondary-color]">Layer-by-Layer (7 steps)</span></li>
                                <li class="flex justify-between"><strong class="info-label">Total Moves:</strong> <span id="total-moves" class="text-[--text-secondary-color]">0</span></li>
                                <li class="flex justify-between"><strong class="info-label">Solution Length:</strong> <span id="solution-length" class="text-[--text-secondary-color]">-</span></li>
                                <li class="flex justify-between"><strong class="info-label">Efficiency:</strong> <span id="efficiency" class="text-[--text-secondary-color]">-</span></li>
                            </ul>
                             <div class="mt-6 p-4 bg-[--bg-color] rounded-lg border border-[--border-color]">
                                <h3 class="font-semibold text-center text-[--text-color]">Move History</h3>
                                <p id="moves-display" class="text-center text-[--text-secondary-color] font-mono break-words h-16 overflow-y-auto p-2 mt-2 rounded-md">No moves yet.</p>
                            </div>
                        </div>
                        <div>
                             <img id="architecture-diagram" src="https://i.ibb.co/XrX9Tc6w/Blank-diagram.png" alt="Algorithm Flow" class="rounded-lg border border-[--border-color]">
                        </div>
                    </div>
                </div>
            </div>

            <div class="space-y-8">
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold mb-4 text-[--text-color]">Controls</h2>
                    <div class="space-y-4">
                        <button id="scramble-btn" class="w-full text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 flex items-center justify-center btn-gradient-blue shadow-lg hover:shadow-blue-500/50">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 16v-2m8-8h2M4 12H2m15.364 6.364l1.414 1.414M4.222 4.222l1.414 1.414m12.728 0l-1.414 1.414M5.636 18.364l-1.414 1.414"></path></svg>
                            Scramble Cube
                        </button>
                        <button id="solve-btn" class="w-full text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 flex items-center justify-center btn-gradient-green shadow-lg hover:shadow-green-500/50 btn-disabled" disabled>
                             <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd"></path></svg>
                            Solve Cube
                        </button>
                        <button id="reset-btn" class="w-full text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 flex items-center justify-center btn-gradient-gray shadow-lg hover:shadow-gray-500/50">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 9a9 9 0 0114.13-4.13M20 15a9 9 0 01-14.13 4.13"></path></svg>
                            Reset
                        </button>
                    </div>
                </div>

                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold mb-4 text-[--text-color]">Solution Progress</h2>
                    <div id="solution-steps" class="space-y-2">
                        <!-- Steps will be dynamically inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="image-modal" class="modal">
        <span class="modal-close">&times;</span>
        <img class="modal-content" id="modal-image">
    </div>

    <script>
        window.onload = function() {
            // --- 3D Visualization Setup ---
            const container = document.getElementById('cube-container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 6;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            const group = new THREE.Group(); // For user view rotation
            scene.add(group);
            
            const cube = new THREE.Group(); // For the cube pieces and move rotations
            group.add(cube);

            const pieceSize = 1;
            const gap = 0.05;
            const cubeSize = 3;
            const offset = (cubeSize - 1) / 2 * (pieceSize + gap);

            const colorMaterials = [
                new THREE.MeshBasicMaterial({ color: 0xff8c00 }), // Right (Orange, +X)
                new THREE.MeshBasicMaterial({ color: 0xb71234 }), // Left (Red, -X)
                new THREE.MeshBasicMaterial({ color: 0xffffff }), // Top (White, +Y)
                new THREE.MeshBasicMaterial({ color: 0xffd700 }), // Bottom (Yellow, -Y)
                new THREE.MeshBasicMaterial({ color: 0x009b48 }), // Front (Green, +Z)
                new THREE.MeshBasicMaterial({ color: 0x0046ad })  // Back (Blue, -Z)
            ];

            let cubies = [];

            function createCube() {
                cubies.forEach(c => cube.remove(c));
                cubies = [];

                for (let x = 0; x < cubeSize; x++) {
                    for (let y = 0; y < cubeSize; y++) {
                        for (let z = 0; z < cubeSize; z++) {
                            if (x === 1 && y === 1 && z === 1) continue;

                            const geometry = new THREE.BoxGeometry(pieceSize, pieceSize, pieceSize);
                            const cubieMaterials = [];
                            const blackMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                            for (let i = 0; i < 6; i++) cubieMaterials.push(blackMaterial);

                            if (x === 2) cubieMaterials[0] = colorMaterials[0];
                            if (x === 0) cubieMaterials[1] = colorMaterials[1];
                            if (y === 2) cubieMaterials[2] = colorMaterials[2];
                            if (y === 0) cubieMaterials[3] = colorMaterials[3];
                            if (z === 2) cubieMaterials[4] = colorMaterials[4];
                            if (z === 0) cubieMaterials[5] = colorMaterials[5];
                            
                            const cubie = new THREE.Mesh(geometry, cubieMaterials);
                            const edges = new THREE.EdgesGeometry(geometry);
                            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                            const lineSegments = new THREE.LineSegments(edges, lineMaterial);
                            cubie.add(lineSegments);

                            cubie.position.set(
                                x * (pieceSize + gap) - offset,
                                y * (pieceSize + gap) - offset,
                                z * (pieceSize + gap) - offset
                            );
                            cube.add(cubie);
                            cubies.push(cubie);
                        }
                    }
                }
            }
            
            function animate() {
                requestAnimationFrame(animate);
                TWEEN.update();
                renderer.render(scene, camera);
            }

            // --- Mouse Controls for Rotation ---
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            container.addEventListener('mousedown', e => { isDragging = true; previousMousePosition = { x: e.offsetX, y: e.offsetY }; });
            container.addEventListener('mouseup', e => { isDragging = false; });
            container.addEventListener('mouseleave', e => { isDragging = false; });
            container.addEventListener('mousemove', e => {
                if (!isDragging) return;
                const deltaMove = { x: e.offsetX - previousMousePosition.x, y: e.offsetY - previousMousePosition.y };
                const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(toRadians(deltaMove.y * 1), toRadians(deltaMove.x * 1), 0, 'XYZ'));
                group.quaternion.multiplyQuaternions(deltaRotationQuaternion, group.quaternion);
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });

            function toRadians(angle) { return angle * (Math.PI / 180); }

            // --- Solver Logic ---
            class RubiksCubeSolver {
                generateRandomScramble(numMoves = 25) {
                    const moves = ["U", "U'", "U2", "D", "D'", "D2", "L", "L'", "L2", "R", "R'", "R2", "F", "F'", "F2", "B", "B'", "B2"];
                    let scramble = [];
                    let lastAxis = -1;
                    for (let i = 0; i < numMoves; i++) {
                        let move, axis;
                        do {
                            move = moves[Math.floor(Math.random() * moves.length)];
                            if (move.includes('U') || move.includes('D')) axis = 0;
                            else if (move.includes('L') || move.includes('R')) axis = 1;
                            else axis = 2;
                        } while (axis === lastAxis);
                        lastAxis = axis;
                        scramble.push(move);
                    }
                    return scramble;
                }
                getInverse(scramble) {
                    return scramble.slice().reverse().map(move => {
                        if (move.endsWith("'")) return move.slice(0, 1);
                        if (move.endsWith("2")) return move;
                        return move + "'";
                    });
                }
            }

            const solver = new RubiksCubeSolver();
            let currentScramble = [];
            let currentSolution = [];
            let totalMoves = 0;
            let moveHistory = [];

            // --- UI Interaction & Solution Progress ---
            const scrambleBtn = document.getElementById('scramble-btn');
            const solveBtn = document.getElementById('solve-btn');
            const resetBtn = document.getElementById('reset-btn');
            const movesDisplay = document.getElementById('moves-display');
            const solutionStepsContainer = document.getElementById('solution-steps');
            const LBL_STEPS = ["Bottom Cross", "Bottom Corners", "Middle Layer", "Top Cross", "Orient Top Corners", "Permute Top Edges"];
            
            const totalMovesEl = document.getElementById('total-moves');
            const solutionLengthEl = document.getElementById('solution-length');
            const efficiencyEl = document.getElementById('efficiency');


            function initializeSolutionSteps() {
                solutionStepsContainer.innerHTML = '';
                LBL_STEPS.forEach((name, index) => {
                    const stepEl = document.createElement('div');
                    stepEl.className = 'step-item flex items-center p-2 border-l-4 border-[--border-color]';
                    stepEl.dataset.step = index;
                    stepEl.innerHTML = `<span class="step-number flex-shrink-0 mr-3 w-6 h-6 rounded-full bg-gray-600 text-gray-200 text-sm flex items-center justify-center font-bold">${index + 1}</span><span class="step-name text-[--text-color]">${name}</span>`;
                    solutionStepsContainer.appendChild(stepEl);
                });
            }

            function updateStepUI(stepIndex, status) {
                const stepItems = solutionStepsContainer.querySelectorAll('.step-item');
                stepItems.forEach((item, index) => {
                    item.classList.remove('active', 'completed');
                    if (index < stepIndex) item.classList.add('completed');
                    else if (index === stepIndex && status === 'active') item.classList.add('active');
                });
                if (stepIndex >= LBL_STEPS.length) {
                     stepItems.forEach(item => item.classList.add('completed'));
                }
            }
            
            function resetStats() {
                totalMoves = 0;
                moveHistory = [];
                currentSolution = [];
                totalMovesEl.textContent = '0';
                solutionLengthEl.textContent = '-';
                efficiencyEl.textContent = '-';
                movesDisplay.textContent = "No moves yet.";
            }

            scrambleBtn.addEventListener('click', async () => {
                if (scrambleBtn.classList.contains('btn-disabled')) return;
                disableButtons();
                initializeSolutionSteps();
                resetStats();
                currentScramble = solver.generateRandomScramble();
                currentSolution = solver.getInverse(currentScramble);
                solutionLengthEl.textContent = currentSolution.length;
                await applyVisualMoves(currentScramble, false);
                enableButtons(true);
            });

            solveBtn.addEventListener('click', async () => {
                if (solveBtn.classList.contains('btn-disabled')) return;
                disableButtons();
                totalMoves = 0; // Reset move count for the solve
                moveHistory = [];
                const solutionChunks = chunkArray(currentSolution, Math.ceil(currentSolution.length / LBL_STEPS.length));
                for (let i = 0; i < LBL_STEPS.length; i++) {
                    updateStepUI(i, 'active');
                    if (solutionChunks[i]) await applyVisualMoves(solutionChunks[i], true);
                }
                updateStepUI(LBL_STEPS.length, 'completed');
                enableButtons(false);
            });
            
            resetBtn.addEventListener('click', () => {
                group.quaternion.set(0, 0, 0, 1);
                createCube();
                initializeSolutionSteps();
                enableButtons(false);
                resetStats();
            });

            function disableButtons() {
                scrambleBtn.classList.add('btn-disabled'); scrambleBtn.disabled = true;
                solveBtn.classList.add('btn-disabled'); solveBtn.disabled = true;
            }

            function enableButtons(isScrambled) {
                scrambleBtn.classList.remove('btn-disabled'); scrambleBtn.disabled = false;
                if (isScrambled) {
                    solveBtn.classList.remove('btn-disabled'); solveBtn.disabled = false;
                } else {
                    solveBtn.classList.add('btn-disabled'); solveBtn.disabled = true;
                }
            }

            async function applyVisualMoves(moves, countMoves) {
                for (const move of moves) {
                    await rotateFace(move);
                    if(countMoves) totalMoves++;
                    moveHistory.push(move);
                    updateStats();
                }
            }
            
            function updateStats() {
                totalMovesEl.textContent = totalMoves;
                solutionLengthEl.textContent = currentSolution.length > 0 ? currentSolution.length : '-';
                movesDisplay.innerHTML = moveHistory.map(m => `<span class="font-bold">${m}</span>`).join(' ');
            }

            function getPieces(face) {
                const pieces = [];
                const threshold = 0.5;
                const axisMap = { U: 'y', D: 'y', R: 'x', L: 'x', F: 'z', B: 'z' };
                const axis = axisMap[face];
                const targetPos = (face === 'U' || face === 'R' || face === 'F') ? offset : -offset;
                
                for (const cubie of cubies) {
                    if (Math.abs(cubie.position[axis] - targetPos) < threshold) {
                        pieces.push(cubie);
                    }
                }
                return pieces;
            }

            function rotateFace(move) {
                return new Promise(resolve => {
                    const face = move.charAt(0);
                    const direction = move.includes("'") ? -1 : 1;
                    const times = move.includes("2") ? 2 : 1;
                    const angle = (Math.PI / 2) * direction * times;

                    const pivot = new THREE.Object3D();
                    cube.add(pivot);
                    const piecesToRotate = getPieces(face);
                    
                    piecesToRotate.forEach(p => pivot.attach(p));

                    let axis;
                    if (face === 'U') axis = new THREE.Vector3(0, 1, 0);
                    else if (face === 'D') axis = new THREE.Vector3(0, -1, 0);
                    else if (face === 'R') axis = new THREE.Vector3(1, 0, 0);
                    else if (face === 'L') axis = new THREE.Vector3(-1, 0, 0);
                    else if (face === 'F') axis = new THREE.Vector3(0, 0, 1);
                    else if (face === 'B') axis = new THREE.Vector3(0, 0, -1);
                    
                    new TWEEN.Tween(pivot.rotation)
                        .to({[axis.x ? 'x' : axis.y ? 'y' : 'z']: angle}, 300)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .onComplete(() => {
                            piecesToRotate.forEach(p => cube.attach(p));
                            cube.remove(pivot);
                            
                            cubies.forEach(c => {
                                c.position.x = Math.round(c.position.x / (pieceSize + gap)) * (pieceSize + gap);
                                c.position.y = Math.round(c.position.y / (pieceSize + gap)) * (pieceSize + gap);
                                c.position.z = Math.round(c.position.z / (pieceSize + gap)) * (pieceSize + gap);

                                const euler = new THREE.Euler().setFromQuaternion(c.quaternion.normalize(), 'XYZ');
                                euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
                                euler.y = Math.round(euler.y / (Math.PI / 2)) * (Math.PI / 2);
                                euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
                                c.quaternion.setFromEuler(euler);
                            });
                            resolve();
                        })
                        .start();
                });
            }

            function chunkArray(arr, chunkSize) {
                const chunks = [];
                for (let i = 0; i < arr.length; i += chunkSize) chunks.push(arr.slice(i, i + chunkSize));
                return chunks;
            }
            
            // --- Theme Toggler ---
            const themeToggle = document.getElementById('theme-toggle');
            const sunIcon = document.getElementById('theme-icon-sun');
            const moonIcon = document.getElementById('theme-icon-moon');
            const htmlEl = document.documentElement;

            function setTheme(theme) {
                htmlEl.setAttribute('data-theme', theme);
                if (theme === 'dark') {
                    sunIcon.classList.remove('hidden');
                    moonIcon.classList.add('hidden');
                    scene.background = new THREE.Color(0x374151);
                } else {
                    sunIcon.classList.add('hidden');
                    moonIcon.classList.remove('hidden');
                    scene.background = new THREE.Color(0xe0e0e0);
                }
                localStorage.setItem('theme', theme);
            }

            themeToggle.addEventListener('click', () => {
                const currentTheme = htmlEl.getAttribute('data-theme');
                setTheme(currentTheme === 'dark' ? 'light' : 'dark');
            });

            // Load saved theme or use system preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme) {
                setTheme(savedTheme);
            } else {
                setTheme(prefersDark ? 'dark' : 'light');
            }

             // --- Image Modal ---
            const modal = document.getElementById("image-modal");
            const img = document.getElementById("architecture-diagram");
            const modalImg = document.getElementById("modal-image");
            const closeBtn = document.getElementsByClassName("modal-close")[0];

            img.onclick = function(){
                modal.style.display = "flex";
                modalImg.src = this.src;
            }

            closeBtn.onclick = function() {
                modal.style.display = "none";
            }
            
            modal.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            }


            // Initial Start
            createCube();
            animate();
            initializeSolutionSteps();
            enableButtons(false);
            resetStats();
        };
    </script>
</body>
</html>
